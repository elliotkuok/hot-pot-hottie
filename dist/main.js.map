{"version":3,"file":"main.js","mappings":"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","sources":["webpack://hot-pot-hottie-main/./src/scripts/order.js","webpack://hot-pot-hottie-main/./src/scripts/game.js","webpack://hot-pot-hottie-main/./src/scripts/arms.js","webpack://hot-pot-hottie-main/./src/scripts/meter.js","webpack://hot-pot-hottie-main/./src/index.js"],"sourcesContent":["import { showX, resetKeyPressedFlag } from './game.js';\n\nconst foodItems = {\n    sausage: { image: 'sausage.png', key: 'w' },\n    mushroom: { image: 'mushroom.png', key: 'a' },\n    shrimp: { image: 'shrimp.png', key: 's' },\n    fishball: { image: 'fishball.png', key: 'd' },\n    meatball: { image: 'meatball.png', key: 'ArrowUp' },\n    dumpling: { image: 'dumpling.png', key: 'ArrowLeft' },\n    bokchoy: { image: 'bokchoy.png', key: 'ArrowDown' },\n    tofu: { image: 'tofu.png', key: 'ArrowRight' },\n};\n\n// Function to randomly select an image key from the foodItems object\nfunction getRandomImageKey() {\n    const keys = Object.keys(foodItems);\n    const randomIndex = Math.floor(Math.random() * keys.length);\n    return keys[randomIndex];\n}\n\nlet timerId = null;\nfunction startTimer(duration) {\n    let timer = duration;\n    const timerInterval = 10; // Update the timer every 10ms\n\n    function updateTimerBar() {\n        const speechBubble = document.getElementById('speech-bubble');\n        let timerBar = speechBubble.querySelector('.timer-bar');\n\n        if (!timerBar) {\n            timerBar = document.createElement('div');\n            timerBar.className = 'timer-bar';\n            const statusBar = document.createElement('div');\n            statusBar.className = 'status-bar'; // Use 'status-bar' class for the timer bar\n            timerBar.appendChild(statusBar);\n            speechBubble.appendChild(timerBar);\n        }\n\n        const statusBar = timerBar.querySelector('.status-bar');\n        const progress = (timer / duration) * 100;\n        statusBar.style.width = `${progress}%`;\n\n        if (timer <= 0) {\n            // Hide the speech-bubble when the timer runs out\n            showX();\n            hideSpeechBubble();\n            clearInterval(timerId);\n            timerId = null;\n        }\n        timer -= timerInterval / 1000;\n    }\n\n    updateTimerBar(); // Call once immediately to show the initial progress\n\n    // Call updateTimerBar every timerInterval (10ms)\n    timerId = setInterval(updateTimerBar, timerInterval);\n}\n\nfunction hideTimerBar() {\n  const speechBubble = document.getElementById('speech-bubble');\n  const timerBar = speechBubble.querySelector('.timer-bar');\n  if (timerBar) {\n    timerBar.style.display = 'none';\n  }\n}\n  \n// Function to display the selected image in the speech-bubble div\nfunction displayRandomImage() {\n  const speechBubble = document.getElementById('speech-bubble');\n  const imageKey = getRandomImageKey();\n  const imageName = foodItems[imageKey].image;\n  const imageSrc = `/assets/food-icons/${imageName}`;\n\n  const imageElement = document.createElement('img');\n  imageElement.src = imageSrc;\n  imageElement.alt = imageKey;\n  imageElement.dataset.key = foodItems[imageKey].key; // Save the assigned key as a data attribute\n  // imageElement.id = imageKey + \"prompt\"; do I need this\n\n  speechBubble.innerHTML = ''; // Clear existing content\n  speechBubble.appendChild(imageElement);\n  startTimer(3);\n\n  resetKeyPressedFlag();\n}\n\nfunction clearImageFromSpeechBubble() {\n  const speechBubble = document.getElementById('speech-bubble');\n  speechBubble.innerHTML = '';\n}\n\nfunction hideSpeechBubble() {\n  const speechBubble = document.getElementById('speech-bubble');\n  const timerBar = speechBubble.querySelector('.timer-bar');\n  if (timerBar) {\n    timerBar.style.display = 'none';\n  }\n  \n  if (!isMatchingKeyPressed) {\n    speechBubble.style.background = '#DD2C00'; // Turn background red only if the matching key wasn't pressed\n  }\n  \n  setTimeout(() => {\n    speechBubble.style.display = 'none';\n    isMatchingKeyPressed = false; // Reset the variable when the timer ends\n    clearImageFromSpeechBubble()\n    setTimeout(() => {\n      showSpeechBubble();\n    }, 2000);\n  }, 500);\n\n}\n\nfunction showSpeechBubble() {\n  if (!isKeyPressed) {\n    const speechBubble = document.getElementById('speech-bubble');\n    speechBubble.style.background = 'white';\n    displayRandomImage();\n    speechBubble.style.display = 'block';\n  }\n}\n\n// Call the displayRandomImage function to show the initial random image\n// displayRandomImage();\n\nlet isMatchingKeyPressed = false;\nlet isKeyPressed = false;\n\ndocument.addEventListener('keydown', (event) => {\n  const keyPressed = event.key;\n  const displayedImageElement = document.querySelector('#speech-bubble img');\n  const displayedImageKey = displayedImageElement ? displayedImageElement.dataset.key : null;\n  const speechBubble = document.getElementById('speech-bubble');\n\n  if (keyPressed === displayedImageKey) {\n    isMatchingKeyPressed = true;\n    isKeyPressed = true;\n    speechBubble.style.background = '#66FF99';\n  } else {\n    isKeyPressed = true;\n    isMatchingKeyPressed = false;\n    speechBubble.style.background = '#DD2C00';\n  }\n  hideTimerBar();\n});\n\ndocument.addEventListener('keyup', (event) => {\n  // const keyLifted = event.key;\n  // const displayedImageElement = document.querySelector('#speech-bubble img');\n  // const displayedImageKey = displayedImageElement ? displayedImageElement.dataset.key : null;\n\n  // // Check if the displayedImageKey is the same as the key lifted\n  // const isMatchingKey = displayedImageKey === keyLifted;\n\n  // if (keyLifted === displayedImageKey) {\n  //   isMatchingKeyPressed = false;\n  // }\n\n  const keyLifted = event.key;\n  const displayedImageElement = document.querySelector('#speech-bubble img');\n\n  if (displayedImageElement) {\n    const displayedImageKey = displayedImageElement.dataset.key;\n    if (keyLifted === displayedImageKey) {\n      isMatchingKeyPressed = false;\n    }\n  }\n  isKeyPressed = false; \n  // setTimeout(() => {\n  //   showSpeechBubble();\n  // }, 2000);\n  // add animation response of putting food into pot\n\n  // displayRandomImage();\n  if (timerId !== null) {\n    clearInterval(timerId);\n    timerId = null;\n  }\n\n  // Show the speech bubble again\n  setTimeout(() => {\n    showSpeechBubble();\n  }, 2000);\n});\n\nexport { displayRandomImage, foodItems }; // Export the function and foodItems hash","import { displayRandomImage } from './order.js';\n\nlet xCount = 0;\nlet isKeyDown = false;\nlet keyPressedSinceLastX = true;\nlet isMatchingKeyPressed = false;\n\nfunction showX() {\n  const gameCanvas = document.getElementById('game-canvas');\n  let missed = gameCanvas.querySelector('.missed');\n  if (xCount < 3 && keyPressedSinceLastX && !isMatchingKeyPressed) {\n      if (!missed) {\n        missed = document.createElement('div');\n        missed.innerText = 'X';\n        missed.className = 'missed';\n        missed.style.position = 'absolute';\n        missed.style.bottom = '5px';\n        missed.style.color = '#DD2C00';\n        missed.style.fontFamily = 'Nerko One';\n        missed.style.fontSize = '60px';\n        gameCanvas.appendChild(missed);\n      } else {\n        missed.innerText += 'X';\n      }\n\n      xCount++;\n      keyPressedSinceLastX = false;\n  }\n}\n\nfunction resetKeyPressedFlag() {\n  keyPressedSinceLastX = true;\n  isMatchingKeyPressed = false;\n}\n\nfunction hideIntroduction() {\n  const introductionDiv = document.getElementById('introduction');\n  introductionDiv.style.display = 'none';\n}\n\nfunction startGame() {\n  hideIntroduction(); // Hide the introduction when the game starts\n  displayRandomImage();\n}\n\nfunction showGameOverModal() {\n  const modal = document.getElementById('game-over-modal');\n  modal.style.display = 'flex';\n}\n\nfunction hideGameOverModal() {\n  const modal = document.getElementById('game-over-modal');\n  modal.style.display = 'none';\n}\n\nfunction restartGame() {\n  xCount = 0; // Reset xCount to 0\n  // Hide any existing \"X\" divs on the screen\n  const gameCanvas = document.getElementById('game-canvas');\n  const missedDivs = gameCanvas.querySelectorAll('.missed');\n  missedDivs.forEach((div) => div.remove());\n  // Call displayRandomImage to start a new game\n  displayRandomImage();\n}\n\nconst startButton = document.getElementById('start-button');\nstartButton.addEventListener('click', startGame);\n\nconst playAgainButton = document.getElementById('play-again-button');\nplayAgainButton.addEventListener('click', () => {\n  hideGameOverModal();\n  restartGame();\n});\n\ndocument.addEventListener('keydown', (event) => {\n  const keyPressed = event.key;\n  const displayedImageKey = document.querySelector('#speech-bubble img').dataset.key;\n  if (keyPressed !== displayedImageKey) {\n    isKeyDown = true;\n  } else if (keyPressed === displayedImageKey) {\n    isMatchingKeyPressed = true;\n  }\n  if (xCount === 3) {\n    showGameOverModal();\n  }\n});\n\ndocument.addEventListener('keyup', (event) => {\n  // isKeyDown = false;\n  // keyPressedSinceLastX = true;\n  // Rest of the code...\n\n  const keyLifted = event.key;\n  const displayedImageKey = document.querySelector('#speech-bubble img').dataset.key;\n  \n  if (keyLifted === displayedImageKey) {\n    isMatchingKeyPressed = false;\n  }\n  keyPressedSinceLastX = true;\n  isKeyDown = false;\n  // showX();\n});\n\n\nexport { showX, resetKeyPressedFlag };","const arm = document.getElementById('right-arm');\nconst dateArms = document.getElementById('date-arms');\n\nfunction moveArmToFood(keyPressed) {\n  const circle = document.querySelector('.circle');\n  const circleLeftPosition = parseFloat(circle.style.left) || 0;\n\n  // Check if the circle position is within the range (125px to 160px)\n  if (circleLeftPosition >= 125 && circleLeftPosition <= 160) {\n    moveArmToHotPot();\n  } else {\n    // Define the new position for the arms based on the key pressed\n    let newX;\n    let newY = 250;\n\n    switch (keyPressed) {\n      case 'w': // Sausage\n        newX = -150;\n        newY = 250;\n        break;\n      case 'a': // Mushroom\n        newX = -150;\n        newY = 250;\n        break;\n      case 's': // Shrimp\n        newX = -150;\n        newY = 250;\n        break;\n      case 'd': // Fishball\n        newX = -150;\n        newY = 250;\n        break;\n      case 'ArrowUp': // Meatball\n        newX = -150;\n        newY = 250;\n        break;\n      case 'ArrowLeft': // Dumpling\n        newX = -150;\n        newY = 250;\n        break;\n      case 'ArrowDown': // Bokchoy\n        newX = -150;\n        newY = 250;\n        break;\n      case 'ArrowRight': // Tofu\n        newX = -150;\n        newY = 250;\n        break;\n      default:\n        // If the key doesn't match any food item, don't move the arms\n        return;\n    }\n\n    // Call the animation function to update the arms' position smoothly\n    animateArm(newX, newY);\n  }\n}\n\nfunction animateArm(targetX, targetY) {\n  // Get the current position of the arms\n  const currentX = parseFloat(arm.style.left) || -200;\n  const currentY = parseFloat(arm.style.top) || 250;\n\n  // Calculate the distance to move in each frame\n  const distanceX = targetX - currentX;\n  const distanceY = targetY - currentY;\n\n  // Define the duration of the animation in milliseconds\n  const duration = 500; // You can adjust this value for faster or slower animation\n\n  // Get the current timestamp\n  let startTime = null;\n\n  // Define the animation function using requestAnimationFrame\n  function animationStep(timestamp) {\n    if (!startTime) startTime = timestamp;\n\n    // Calculate the time elapsed since the animation started\n    const elapsedTime = timestamp - startTime;\n\n    // Calculate the progress of the animation (a value between 0 and 1)\n    const progress = Math.min(elapsedTime / duration, 1);\n\n    // Calculate the new position of the arms based on the progress\n    const newX = currentX + distanceX * progress;\n    const newY = currentY + distanceY * progress;\n\n    // Update the position of the arms\n    arm.style.left = `${newX}px`;\n    arm.style.top = `${newY}px`;\n    // dateArms.style.left = `${newX}px`;\n    // dateArms.style.top = `${newY}px`;\n\n    // Check if the animation is still in progress\n    if (progress < 1) {\n      // If the animation is not complete, request the next frame\n      requestAnimationFrame(animationStep);\n    }\n  }\n\n  // Start the animation by requesting the first frame\n  requestAnimationFrame(animationStep);\n}\n\nfunction moveArmToHotPot() {\n  // Define the new position for the arms to the hot pot position\n  const newX = -50; // Adjust this value based on your desired hot pot position\n  const newY = 250; // Adjust this value based on your desired hot pot position\n\n  const originX = -200; // Adjust this value based on your desired hot pot position\n  const originY = 250;\n  // Call the animation function to update the arms' position smoothly\n  animateArm(newX, newY);\n  setTimeout(() => {\n    \n    animateArm(originX, originY);\n  }, 1500);\n}\n\n\ndocument.addEventListener('keydown', (event) => {\n  const keyPressed = event.key;\n  const displayedImageKey = document.querySelector('#speech-bubble img').dataset.key;\n  if (keyPressed === displayedImageKey) {\n    moveArmToFood(keyPressed)\n  }\n});\n\n// Export the moveArmsToNewPosition function to use it in other files\nexport default moveArmToFood;\n","import moveArmToFood from './arms.js';\nimport { showX, resetKeyPressedFlag } from './game.js';\n\nconst circle = document.querySelector('.circle');\nconst meterWidth = 300;\nlet animationId;\nlet currentPosition = 0;\nlet moveSpeed = 2; // Setting to 3 for now but remember to change\nlet moveDirection = 'right';\nlet isCircleInDesiredRange = false;\n\nfunction moveCircle() {\n  if (moveDirection === 'right') {\n    currentPosition += moveSpeed;\n  } else {\n    currentPosition -= moveSpeed;\n  }\n\n  circle.style.left = `${currentPosition}px`;\n\n  isCircleInDesiredRange = currentPosition >= 125 && currentPosition <= 160;\n\n  if (currentPosition >= meterWidth - circle.clientWidth || currentPosition <= 0) {\n    moveDirection = moveDirection === 'right' ? 'left' : 'right';\n  }\n\n  animationId = requestAnimationFrame(moveCircle);\n}\n\nfunction stopMovingCircle() {\n  cancelAnimationFrame(animationId);\n  const circleLeftPosition = parseFloat(circle.style.left);\n  const displayedImageKey = document.querySelector('#speech-bubble img')?.dataset?.key ?? '';\n  if (circleLeftPosition < 125 || circleLeftPosition > 160) {\n    // const displayedImageKey = document.querySelector('#speech-bubble img').dataset.key;\n    showX(displayedImageKey);\n  }\n  // const displayedImageKey = document.querySelector('#speech-bubble img').dataset.key;\n  // setTimeout(() => {\n  //   moveArmToNewPosition(displayedImageKey);\n  // }, 500); // making the animation run async\n}\n\nfunction displayMeter() {\n  const meter = document.getElementById('meter');\n  meter.style.display = 'block';\n}\n\nfunction turnMeterColor() {\n  const progressBar = document.querySelector('.progress');\n  if (isCircleInDesiredRange) {\n    progressBar.style.background = '#66FF99';\n    progressBar.style.border = 'yellow';\n  } else {\n    progressBar.style.background = '#DD2C00';\n    showX();\n  }\n  setTimeout(() => {\n    meter.style.display = 'none';\n    resetMeterAnimation();\n  }, 500);\n}\n\nfunction resetMeterAnimation() {\n  const progressBar = document.querySelector('.progress');\n  const gradientValue = 'linear-gradient(to right, #DD2C00 35%, #66FF99 45%, #66FF99 55%, #DD2C00 65%)';\n\n  progressBar.style.background = gradientValue;\n  currentPosition = 0; // Reset the current position of the circle\n  moveDirection = 'right'; // Reset the direction of movement to right\n  moveCircle(); // Start the meter animation again\n}\n\ndocument.addEventListener('keydown', (event) => {\n  const keyPressed = event.key;\n  const displayedImageKey = document.querySelector('#speech-bubble img').dataset.key;\n  if (keyPressed === displayedImageKey) {\n    displayMeter();\n  } else {\n    showX();\n  }\n});\n\ndocument.addEventListener('keyup', () => {\n  stopMovingCircle();\n  turnMeterColor()\n});\n\nmoveCircle();\n\n// Export the functions to use them in the main game logic (index.js)\nexport { moveCircle, stopMovingCircle }; \n\n","import { handlePickUpFood, handleDropFood } from './scripts/foodInteractions';\nimport showX from './scripts/game.js';\nimport { moveCircle, stopMovingCircle } from './scripts/meter.js';\nimport './index.scss';\nimport './scripts/order.js';\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    // Your game setup and initialization code here\n  \n    // Add event listeners for user interactions, e.g., adding food to the hotpot\n\n\n});"],"names":["foodItems","sausage","image","key","mushroom","shrimp","fishball","meatball","dumpling","bokchoy","tofu","timerId","displayRandomImage","speechBubble","document","getElementById","imageKey","keys","Object","Math","floor","random","length","getRandomImageKey","imageSrc","imageElement","createElement","src","alt","dataset","innerHTML","appendChild","duration","timer","updateTimerBar","timerBar","querySelector","className","statusBar","progress","style","width","showX","display","isMatchingKeyPressed","background","setTimeout","showSpeechBubble","hideSpeechBubble","clearInterval","timerInterval","setInterval","startTimer","keyPressedSinceLastX","isKeyPressed","addEventListener","event","keyPressed","displayedImageElement","displayedImageKey","hideTimerBar","keyLifted","xCount","isKeyDown","gameCanvas","missed","innerText","position","bottom","color","fontFamily","fontSize","querySelectorAll","forEach","div","remove","arm","animateArm","targetX","targetY","currentX","parseFloat","left","currentY","top","distanceX","distanceY","startTime","requestAnimationFrame","animationStep","timestamp","elapsedTime","min","newX","newY","circle","circleLeftPosition","moveArmToFood","meterWidth","animationId","currentPosition","moveSpeed","moveDirection","isCircleInDesiredRange","moveCircle","clientWidth","cancelAnimationFrame","stopMovingCircle","progressBar","border","meter","turnMeterColor"],"sourceRoot":""}